use std::str;

/// Format cgroup name from raw cgroup_info data
/// This is generic to work with different cgroup_info types generated by libbpf-cargo
pub fn format_cgroup_name<T>(cgroup_info: &T) -> String
where
    T: CgroupInfo,
{
    let name = str::from_utf8(cgroup_info.name())
        .unwrap_or("")
        .trim_end_matches(char::from(0))
        .replace("\\x2d", "-");

    let pname = str::from_utf8(cgroup_info.pname())
        .unwrap_or("")
        .trim_end_matches(char::from(0))
        .replace("\\x2d", "-");

    let gpname = str::from_utf8(cgroup_info.gpname())
        .unwrap_or("")
        .trim_end_matches(char::from(0))
        .replace("\\x2d", "-");

    if !gpname.is_empty() {
        if cgroup_info.level() > 3 {
            format!(".../{gpname}/{pname}/{name}")
        } else {
            format!("/{gpname}/{pname}/{name}")
        }
    } else if !pname.is_empty() {
        format!("/{pname}/{name}")
    } else if !name.is_empty() {
        format!("/{name}")
    } else {
        "".to_string()
    }
}

/// Trait for accessing cgroup_info fields
pub trait CgroupInfo {
    fn id(&self) -> i32;
    fn level(&self) -> i32;
    fn name(&self) -> &[u8];
    fn pname(&self) -> &[u8];
    fn gpname(&self) -> &[u8];
}

/// Set cgroup name metadata on a CounterGroup
pub fn set_cgroup_metadata_counter(id: usize, name: &str, metric: &crate::agent::CounterGroup) {
    if !name.is_empty() {
        metric.insert_metadata(id, "name".to_string(), name.to_string());
    }
}

/// Set cgroup name metadata on a GaugeGroup
pub fn set_cgroup_metadata_gauge(id: usize, name: &str, metric: &crate::agent::GaugeGroup) {
    if !name.is_empty() {
        metric.insert_metadata(id, "name".to_string(), name.to_string());
    }
}

/// Macro to implement CgroupInfo trait for BPF-generated cgroup_info types
#[macro_export]
macro_rules! impl_cgroup_info {
    ($type_path:path) => {
        unsafe impl plain::Plain for $type_path {}

        impl $crate::agent::bpf::cgroup::CgroupInfo for $type_path {
            fn id(&self) -> i32 {
                self.id
            }

            fn level(&self) -> i32 {
                self.level
            }

            fn name(&self) -> &[u8] {
                &self.name
            }

            fn pname(&self) -> &[u8] {
                &self.pname
            }

            fn gpname(&self) -> &[u8] {
                &self.gpname
            }
        }
    };
}
