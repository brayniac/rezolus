use std::str;

/// Format cgroup name from raw cgroup_info data
/// This is generic to work with different cgroup_info types generated by libbpf-cargo
pub fn format_cgroup_name<T>(cgroup_info: &T) -> String
where
    T: CgroupInfo,
{
    let name = str::from_utf8(cgroup_info.name())
        .unwrap_or("")
        .trim_end_matches(char::from(0))
        .replace("\\x2d", "-");

    let pname = str::from_utf8(cgroup_info.pname())
        .unwrap_or("")
        .trim_end_matches(char::from(0))
        .replace("\\x2d", "-");

    let gpname = str::from_utf8(cgroup_info.gpname())
        .unwrap_or("")
        .trim_end_matches(char::from(0))
        .replace("\\x2d", "-");

    if !gpname.is_empty() {
        if cgroup_info.level() > 3 {
            format!(".../{gpname}/{pname}/{name}")
        } else {
            format!("/{gpname}/{pname}/{name}")
        }
    } else if !pname.is_empty() {
        format!("/{pname}/{name}")
    } else if !name.is_empty() {
        format!("/{name}")
    } else {
        "".to_string()
    }
}

/// Trait for accessing cgroup_info fields
pub trait CgroupInfo {
    fn id(&self) -> i32;
    fn level(&self) -> i32;
    fn name(&self) -> &[u8];
    fn pname(&self) -> &[u8];
    fn gpname(&self) -> &[u8];
}

/// Trait for metric groups that support metadata
pub trait MetricGroup {
    fn insert_metadata(&self, idx: usize, key: String, value: String);
}

impl MetricGroup for crate::agent::CounterGroup {
    fn insert_metadata(&self, idx: usize, key: String, value: String) {
        self.insert_metadata(idx, key, value);
    }
}

impl MetricGroup for crate::agent::GaugeGroup {
    fn insert_metadata(&self, idx: usize, key: String, value: String) {
        self.insert_metadata(idx, key, value);
    }
}

/// Set cgroup name metadata on any metric group
pub fn set_name<T: MetricGroup>(id: usize, name: &str, metric: &T) {
    if !name.is_empty() {
        metric.insert_metadata(id, "name".to_string(), name.to_string());
    }
}

/// Generic handler for cgroup events
pub fn handle_cgroup_event<T>(data: &[u8], metrics: &[&dyn MetricGroup]) -> i32
where
    T: CgroupInfo + Default + plain::Plain,
{
    let mut cgroup_info = T::default();
    
    if plain::copy_from_bytes(&mut cgroup_info, data).is_ok() {
        let name = format_cgroup_name(&cgroup_info);
        let id = cgroup_info.id() as usize;
        
        // Set metadata for all metrics
        for metric in metrics {
            set_name(id, &name, *metric);
        }
    }
    
    0
}

/// Macro to implement CgroupInfo trait for BPF-generated cgroup_info types
#[macro_export]
macro_rules! impl_cgroup_info {
    ($type_path:path) => {
        unsafe impl plain::Plain for $type_path {}

        impl $crate::agent::bpf::cgroup::CgroupInfo for $type_path {
            fn id(&self) -> i32 {
                self.id
            }

            fn level(&self) -> i32 {
                self.level
            }

            fn name(&self) -> &[u8] {
                &self.name
            }

            fn pname(&self) -> &[u8] {
                &self.pname
            }

            fn gpname(&self) -> &[u8] {
                &self.gpname
            }
        }
    };
}
