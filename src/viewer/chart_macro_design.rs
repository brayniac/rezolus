// Proposed architecture for cleaner chart definitions using derive macros
// This file shows the design - actual implementation would need proc macros

use linkme::distributed_slice;
use serde::Serialize;

// === Core Types ===

#[derive(Debug, Clone, Serialize)]
pub struct ChartMetadata {
    pub short_title: &'static str,      // e.g., "CPU Usage"
    pub long_title: &'static str,       // e.g., "CPU Utilization Percentage"
    pub description: &'static str,      // What this chart shows
    pub keywords: &'static [&'static str], // For search/matching
    pub use_cases: &'static str,       // When to use this chart
    pub section: ChartSection,         // Which section it belongs to
    pub group: &'static str,           // Group within section
    pub chart_type: ChartType,         // Line, Heatmap, etc.
}

#[derive(Debug, Clone, Copy, Serialize)]
pub enum ChartSection {
    Cpu,
    Network,
    Disk,
    Memory,
    Scheduler,
    System,
}

#[derive(Debug, Clone, Copy, Serialize)]
pub enum ChartType {
    Line,
    Heatmap,
    Scatter,
    Multi,
}

// === Chart Definition Trait ===

pub trait ChartDefinition: Send + Sync {
    fn metadata(&self) -> &ChartMetadata;
    fn generate(&self, data: &Tsdb) -> Option<Plot>;
}

// === Distributed Slice for Auto-Collection ===

#[distributed_slice]
pub static CHARTS: [&'static dyn ChartDefinition];

// === Example Usage with Attribute Macros ===

// This is how charts would be defined:

#[chart(
    short_title = "CPU Usage",
    long_title = "CPU Utilization Percentage", 
    description = "Percentage of CPU time spent executing processes. High sustained values (>80%) indicate CPU saturation.",
    keywords = ["cpu", "usage", "utilization", "busy", "processor"],
    use_cases = "Monitor for performance bottlenecks, capacity planning, baseline establishment",
    section = Cpu,
    group = "utilization",
    chart_type = Line,
)]
pub struct CpuUsageChart;

impl ChartDefinition for CpuUsageChart {
    fn metadata(&self) -> &ChartMetadata {
        &METADATA // Generated by macro
    }
    
    fn generate(&self, data: &Tsdb) -> Option<Plot> {
        Plot::line(
            self.metadata().long_title,
            "cpu-usage",
            Unit::Percentage,
            data.cpu_avg("cpu_usage", ()).map(|v| v / 1000000000.0),
        )
    }
}

// The macro would generate this:
#[distributed_slice(CHARTS)]
static CPU_USAGE_CHART: &'static CpuUsageChart = &CpuUsageChart;

// === Alternative: Builder Pattern with Const ===

// For simpler cases without custom logic:
pub const CPU_IDLE: ChartDef = ChartDef::new()
    .short_title("CPU Idle")
    .long_title("CPU Idle Percentage")
    .description("Percentage of time CPU cores are idle")
    .keywords(&["cpu", "idle", "available"])
    .section(ChartSection::Cpu)
    .group("utilization")
    .chart_type(ChartType::Line)
    .metric("cpu_idle", Unit::Percentage);

// === Declarative Chart Groups ===

#[chart_group(
    name = "CPU Utilization",
    id = "cpu-utilization",
    section = Cpu,
)]
pub mod cpu_utilization {
    #[chart(
        short = "Busy %",
        long = "CPU Busy Percentage",
        desc = "CPU time spent on work",
    )]
    fn cpu_busy(data: &Tsdb) -> Option<Plot> {
        // Implementation
    }
    
    #[chart(
        short = "User %", 
        long = "CPU User Mode Percentage",
        desc = "CPU time in user space",
    )]
    fn cpu_user(data: &Tsdb) -> Option<Plot> {
        // Implementation
    }
}

// === Advanced: Related Charts ===

#[chart(
    short_title = "Network RX",
    long_title = "Network Bytes Received per Second",
    related_charts = ["Network TX", "Network Packets RX", "Network Errors"],
    alert_thresholds = { warning: 80_000_000, critical: 95_000_000 }, // bytes/sec
)]
pub struct NetworkRxChart;

// === Benefits of This Approach ===

// 1. Declarative - Charts defined with attributes, not imperative code
// 2. Discoverable - All charts automatically collected via distributed_slice
// 3. Searchable - Rich metadata for LLM/search
// 4. Maintainable - Chart definitions in one place with their logic
// 5. Type-safe - Compiler validates metadata
// 6. Extensible - Easy to add new metadata fields

// === Chart Registry ===

pub struct ChartRegistry {
    charts: Vec<&'static dyn ChartDefinition>,
}

impl ChartRegistry {
    pub fn new() -> Self {
        Self {
            charts: CHARTS.iter().copied().collect(),
        }
    }
    
    pub fn get_by_section(&self, section: ChartSection) -> Vec<&dyn ChartDefinition> {
        self.charts
            .iter()
            .filter(|c| c.metadata().section == section)
            .copied()
            .collect()
    }
    
    pub fn search(&self, query: &str) -> Vec<&dyn ChartDefinition> {
        let query_lower = query.to_lowercase();
        self.charts
            .iter()
            .filter(|c| {
                let meta = c.metadata();
                meta.short_title.to_lowercase().contains(&query_lower) ||
                meta.long_title.to_lowercase().contains(&query_lower) ||
                meta.keywords.iter().any(|k| k.contains(&query_lower))
            })
            .copied()
            .collect()
    }
    
    pub fn generate_dashboard(&self, data: &Tsdb, section: ChartSection) -> View {
        let mut view = View::new(data);
        
        // Group charts by their group field
        let mut groups: HashMap<&str, Vec<&dyn ChartDefinition>> = HashMap::new();
        
        for chart in self.get_by_section(section) {
            groups.entry(chart.metadata().group)
                .or_default()
                .push(chart);
        }
        
        // Generate plots for each group
        for (group_name, charts) in groups {
            let mut group = Group::new(group_name, group_name);
            
            for chart in charts {
                if let Some(plot) = chart.generate(data) {
                    group.push(Some(plot));
                }
            }
            
            view.group(group);
        }
        
        view
    }
}

// === Export Metadata for Frontend ===

pub fn export_chart_catalog() -> String {
    let catalog: Vec<_> = CHARTS
        .iter()
        .map(|chart| chart.metadata())
        .collect();
    
    serde_json::to_string_pretty(&catalog).unwrap()
}